---
title: 如何只在栈(堆)上分配空间给类对象
key: 2017-03-03
tags: C++
---

一般来说，新建一个实例或对象，是可以在栈或者堆上分配内存空间的。但是有这么个问题（来自牛客网的一道测试题）：如何限制一个类对象只在栈（堆）上分配空间？

<!--more-->

在C++下，类对象的建立有两种方式：静态和动态。静态比如`ClassA a;`，动态如`ClassA *p = new ClassA();`

静态建立：是直接由编译器在栈上分配内存的，通过移动栈顶指针，利用构造函数生成一个对象。

动态建立：是使用new运算符在堆上建立对象的。先是通过`operator new`在堆上找到合适的内存空间进行分配，再是调用构造函数生成。

简单来说，就是一个直接调用构造函数，一个间接调用了构造函数。



回到问题上来：

* 只在堆上构造类对象

  ​	明显不能通过静态方式来建立对象了。首先会想到将构造函数私有化，私有化之后，就无法在类外部调用构造函数直接构造对象了，只能通过new来建立，但是前面说过，new方式是动态的建立，还是需要调用构造函数的。所以构造函数私有化是不可取的。

  ​	对象建立在栈上的时候，是由编译器来分配内存空间的，当对象需要释放时，也是通过编译器来调用析构函数来释放栈中空间的。也就是说栈上的对象实例是由编译器来管理生命周期的。那么，编译器没办法调用析构函数的时候，是不是就可以了呢？假若类的析构函数是私有的，编译器将无法释放内存空间。而事实也是，编译器在为类对象分配空间的时候，会检查析构函数，当析构函数私有的时候，编译器就无法在栈上为类对象分配内存空间了。其实，编译器不仅会检查析构函数，只要是非静态的方法，编译器都会检查。

* 只在栈上构造类对象

  ​	同理，只在栈上构造对象，只需要禁用new运算符就可以了。将`operator new`重写私有化即可。



Referring to：[c++中堆、栈内存分配](http://www.cnblogs.com/h2-database/archive/2012/06/28/2572497.html)
